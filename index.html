import random
import time

# --- Game Constants ---
BASE_FIRE_RATE = 0.7  # shots per second
AMMO_REWARD_CORRECT = 5
LIVES_START = 10
WAVE_BOSS_INTERVAL = 5
QUIZ_DURATION = 10  # seconds
SHOP_DURATION = 30  # seconds

# --- Upgrade Max Levels and Costs ---
UPGRADES = {
    'fire_rate': {'cost': 100, 'effect': 0.25, 'max_level': 5},
    'ship_speed': {'cost': 150, 'effect': 0.20, 'max_level': 3},
    'shield_generator': {'cost': 200, 'effect': 1, 'max_level': 3}
}


class Player:
    def __init__(self):
        self.lives = LIVES_START
        self.score = 0
        self.ammo = 50  # Starting ammo for initial wave
        self.current_wave = 1
        
        # Upgrade Stats
        self.upgrades = {k: 0 for k in UPGRADES.keys()}
        self.shields = 0
        
    def get_fire_rate(self):
        # Base + (level * effect)
        boost = self.upgrades['fire_rate'] * UPGRADES['fire_rate']['effect']
        return BASE_FIRE_RATE + boost

    def get_speed_multiplier(self):
        # Base 1.0 + (level * effect)
        boost = self.upgrades['ship_speed'] * UPGRADES['ship_speed']['effect']
        return 1.0 + boost
        
    def lose_life(self, count=1):
        if self.shields > 0:
            self.shields -= 1
            print("Shield absorbed a hit!")
        else:
            self.lives -= count
            if self.lives <= 0:
                return "GAME_OVER"
        return "HIT"

    def buy_upgrade(self, key):
        if self.upgrades[key] < UPGRADES[key]['max_level']:
            cost = UPGRADES[key]['cost'] * (self.upgrades[key] + 1) # Example cumulative cost
            if self.score >= cost:
                self.score -= cost
                self.upgrades[key] += 1
                if key == 'shield_generator':
                    self.shields += UPGRADES[key]['effect']
                return True
        return False


class AlienWave:
    def __init__(self, wave_number):
        self.wave_number = wave_number
        # Alien Count: Wave Number * 3
        self.total_aliens = wave_number * 3 
        self.aliens_remaining = self.total_aliens

    def check_clear(self):
        return self.aliens_remaining <= 0


class Boss:
    def __init__(self, wave_number, boss_type):
        self.boss_type = boss_type
        self.wave_number = wave_number
        
        # Boss Health Formula: Wave Number * 5
        base_hp = wave_number * 5 
        
        # Fortress Boss has twice the health
        if boss_type == "Fortress Boss":
            self.health = base_hp * 2
        else:
            self.health = base_hp
            
        self.max_health = self.health

    def take_damage(self, damage):
        self.health -= damage
        return self.health <= 0

    def get_score_value(self):
        # Boss Scoring: Points equal to the Boss's current Health value at defeat
        return self.max_health 
        
    def get_move_speed(self):
        # Fortress Boss moves 25% slower (0.75x speed)
        return 0.75 if self.boss_type == "Fortress Boss" else 1.0


class PowerUpSpawner:
    def __init__(self):
        self.chance = 0.10  # Starts at 10%
        self.powerup_types = {
            'BOMB': {'chance': 0.45, 'color': 'Orange'},
            'TRIPLE_SHOT': {'chance': 0.175, 'color': 'Blue'},
            'ROCKETS': {'chance': 0.15, 'color': 'Red'},
            'EXTRA_LIFE': {'chance': 0.05, 'color': 'Pink'},
            'MACHINE_GUN': {'chance': 0.175, 'color': 'Green'}
        }
        
    def roll_spawn(self):
        # Roll to see if *any* power-up spawns
        if random.random() < self.chance:
            self.chance = 0.10 # Reset chance upon spawn
            
            # Weighted random selection of Power-Up type
            roll = random.random()
            cumulative_chance = 0.0
            for pu_type, data in self.powerup_types.items():
                cumulative_chance += data['chance']
                if roll <= cumulative_chance:
                    return pu_type
        else:
            # Increase chance by 10% for the next wave
            self.chance = min(1.0, self.chance + 0.10) 
            return None # No power-up spawned


# --- Main Game Loop Structure (Conceptual) ---
def run_game():
    player = Player()
    powerup_spawner = PowerUpSpawner()
    boss_list = ["Fortress Boss", "Spider Boss", "Crystal Boss", "Destroyer Boss"]
    last_boss = None

    while player.lives > 0:
        wave_num = player.current_wave

        # 1. Shop Phase (Every 5th wave)
        if wave_num % WAVE_BOSS_INTERVAL == 0:
            print(f"\n--- SHOP APPEARS (30s) before BOSS WAVE {wave_num} ---")
            # Developer note: In a real game, this is where the shop UI and timer runs
            # The player can spend score here before the boss fight.
            
        # 2. Boss Wave or Regular Wave
        if wave_num % WAVE_BOSS_INTERVAL == 0:
            # Boss selection logic: ensure different boss than last time
            available_bosses = [b for b in boss_list if b != last_boss]
            current_boss_type = random.choice(available_bosses)
            last_boss = current_boss_type
            
            boss = Boss(wave_num, current_boss_type)
            print(f"\n--- BOSS WAVE {wave_num} --- BOSS: {current_boss_type} (HP: {boss.health})")
            
            # --- Boss Wave Combat Loop (Conceptual) ---
            # ... Code for boss movement, attacks, player firing, damage ...
            
            if boss.health <= 0:
                score_gain = boss.get_score_value()
                player.score += score_gain
                print(f"Boss Defeated! Player Score: +{score_gain}")
            else:
                # Assuming Game Over condition handled by player.lose_life() during combat
                pass
                
        else:
            # Regular Alien Wave
            wave = AlienWave(wave_num)
            print(f"\n--- WAVE {wave_num} --- Aliens: {wave.total_aliens}")
            
            # Spawn Power-up (if applicable)
            powerup = powerup_spawner.roll_spawn()
            if powerup:
                print(f"**A POWER-UP SPARKED**: {powerup} ({powerup_spawner.powerup_types[powerup]['color']})")
                # Developer note: In a real game, spawn the power-up sprite here.

            # --- Alien Wave Combat Loop (Conceptual) ---
            # ... Code for alien movement, player firing, scoring, alien reaching bottom ...
            
            # Simulate wave clear:
            # If (wave cleared and player lives > 0):
            player.score += wave.total_aliens # Points for defeat
            print(f"Wave {wave_num} cleared!")
            
            # 3. Quiz Phase (After non-boss waves)
            print(f"\n--- QUIZ BREAK (10s) ---")
            
            # In a real game, a quiz UI and timer starts here
            quiz_loop(player) # Run quiz
            
        player.current_wave += 1

    print("\n--- GAME OVER ---")
    print(f"Final Score: {player.score}")
    print(f"Waves Survived: {player.current_wave - 1}")


# --- QUIZ FUNCTION (Conceptual) ---
incorrectly_answered_questions = []

def quiz_loop(player):
    # Retrieve a question (logic to select/remove/recall questions goes here)
    question, answer = get_random_question() # See Part 2 for the bank
    
    # Check for recalled question chance
    if incorrectly_answered_questions and random.random() < 0.25:
        q_data = random.choice(incorrectly_answered_questions)
        question, answer = q_data['q'], q_data['a']
        
    print(f"Question: {question}")
    # In a real game: get player input within the 10s limit
    
    is_correct = True # Simplified for this demo
    
    if is_correct:
        player.ammo += AMMO_REWARD_CORRECT
        print(f"CORRECT! +{AMMO_REWARD_CORRECT} Ammo. Total Ammo: {player.ammo}")
        # Remove from recall list if it was a recalled question
        if {'q': question, 'a': answer} in incorrectly_answered_questions:
            incorrectly_answered_questions.remove({'q': question, 'a': answer})
    else:
        player.lose_life()
        print(f"INCORRECT! -1 Life. Lives Remaining: {player.lives}")
        # Add to recall list
        incorrectly_answered_questions.append({'q': question, 'a': answer})

# run_game() # Uncomment to run the conceptual structure
QUIZ_BANK = {
    "Structure of the Earth": [
        ("T/F: The mantle is the thinnest layer of the Earth.", "False"),
        ("The solid, innermost layer of the Earth is called the: A) Outer Core, B) Inner Core, C) Crust", "B"),
        ("T/F: The asthenosphere is a solid, rigid layer.", "False"),
        ("Which layer is liquid iron and nickel? A) Mantle, B) Outer Core, C) Inner Core", "B"),
        ("T/F: The lithosphere includes the crust and the uppermost part of the mantle.", "True"),
        ("The boundary between the crust and the mantle is known as the: A) Moho, B) Gutenburg, C) Lehman", "A"),
        ("T/F: Density increases as you move from the crust toward the core.", "True"),
        ("Which is thicker: A) Continental Crust, B) Oceanic Crust?", "A"),
        ("The process of heat transfer in the mantle is called: A) Radiation, B) Conduction, C) Convection", "C"),
        ("T/F: The core makes up the majority of Earth's volume.", "False")
    ],
    "Tectonics / Faultlines": [
        ("T/F: The San Andreas Fault is an example of a convergent boundary.", "False"),
        ("New crust is created at which type of boundary? A) Divergent, B) Convergent, C) Transform", "A"),
        ("T/F: Earthquakes only occur at plate boundaries.", "False"),
        ("When plates slide past each other, it forms a: A) Normal Fault, B) Reverse Fault, C) Strike-slip Fault", "C"),
        ("Subduction zones are found at which boundary? A) Divergent, B) Convergent, C) Transform", "B"),
        ("T/F: Fold mountains are typically formed by reverse faulting.", "True"),
        ("The 'Ring of Fire' is dominated by which type of plate boundary activity?", "Convergent"),
        ("T/F: Tectonic plates move at speeds of several meters per year.", "False"),
        ("The mechanism that drives plate movement is primarily: A) Gravity, B) Convection Currents, C) Magnetic Poles", "B"),
        ("A hanging wall moving down relative to the footwall indicates a: A) Normal Fault, B) Reverse Fault", "A")
    ],
    "The Rock Cycle / Identifying Rocks": [
        ("T/F: Igneous rocks are formed from solidified magma or lava.", "True"),
        ("Limestone is an example of which rock type? A) Igneous, B) Sedimentary, C) Metamorphic", "B"),
        ("T/F: Gneiss is a non-foliated metamorphic rock.", "False"),
        ("Which rock is dark, fine-grained, and forms the oceanic crust? A) Granite, B) Basalt, C) Shale", "B"),
        ("T/F: Weathering and erosion are the first steps in forming metamorphic rock.", "False"),
        ("The process of turning sediment into rock is called: A) Crystallization, B) Lithification, C) Metamorphism", "B"),
        ("T/F: Quartzite is a metamorphic rock formed from limestone.", "False"),
        ("An intrusive igneous rock that cooled slowly beneath the surface is: A) Obsidian, B) Pumice, C) Granite", "C"),
        ("Marble is formed from the metamorphism of which sedimentary rock?", "Limestone"),
        ("T/F: Sedimentary rocks are the only type of rock that can contain fossils.", "True")
    ],
    "Geology of Te Arawa": [ # Specific to Rotorua context, great customization!
        ("T/F: The Rotorua basin is a volcanic caldera formed by a massive eruption.", "True"),
        ("The geothermal activity in Rotorua is primarily powered by the presence of: A) A hot spot, B) A shallow magma body, C) Plate subduction", "B"),
        ("T/F: The hot pools in Rotorua are heated by steam rising from deep aquifers.", "True"),
        ("The volcanic zone covering Rotorua is part of the: A) Taupō Volcanic Zone, B) Taranaki Volcanic Field", "A"),
        ("T/F: Lake Rotorua formed in the caldera depression after the main eruption.", "True"),
        ("The type of geothermal feature that periodically erupts a column of hot water and steam is a:", "Geyser"),
        ("T/F: The main rock type surrounding the Rotorua geothermal area is sedimentary shale.", "False"),
        ("The eruption that formed the Rotorua caldera is estimated to have occurred approximately: A) 100 years ago, B) 50,000 years ago, C) 240,000 years ago", "C"),
        ("T/F: The smell of sulfur in Rotorua comes from dissolved gases escaping the hot spring water.", "True"),
        ("Which famous geyser is located near Rotorua? A) Lady Knox Geyser, B) Pohutu Geyser, C) Old Faithful", "B")
    ],
    "Our Solar System and Orbits": [
        ("T/F: The Sun is a planet.", "False"),
        ("The largest planet in our solar system is: A) Saturn, B) Jupiter, C) Neptune", "B"),
        ("T/F: All planets in our solar system orbit the Sun in the same direction.", "True"),
        ("Which planet is known as the 'Red Planet'? A) Venus, B) Mars, C) Mercury", "B"),
        ("T/F: An asteroid is the same as a meteoroid.", "False"),
        ("The Kuiper Belt is located beyond the orbit of which planet?", "Neptune"),
        ("T/F: Earth's orbit is a perfect circle.", "False"),
        ("The time it takes a planet to complete one revolution around the Sun is its:", "Orbital Period"),
        ("T/F: The four inner planets are primarily composed of rock and metal.", "True"),
        ("Which gas giant has the lowest density, allowing it to float in water (hypothetically)?", "Saturn")
    ],
    "Seasons & Tides": [
        ("T/F: The Earth is closest to the Sun during the Northern Hemisphere's summer.", "False"),
        ("Seasons are caused by the Earth's: A) Distance from the Sun, B) Axial Tilt, C) Orbital Speed", "B"),
        ("T/F: Neap tides occur when the Sun, Earth, and Moon are aligned.", "False"),
        ("Tides are primarily caused by the gravitational pull of the: A) Sun, B) Moon, C) Jupiter", "B"),
        ("T/F: The equinoxes mark the days when the length of day and night are nearly equal.", "True"),
        ("Spring tides result in: A) Higher high tides and lower low tides, B) Milder tides overall", "A"),
        ("T/F: The Southern Hemisphere's winter solstice occurs in December.", "False"),
        ("The Earth's axial tilt is approximately: A) 15.5 degrees, B) 23.5 degrees, C) 45 degrees", "B"),
        ("T/F: A single location experiences high tide once per day.", "False"),
        ("The highest tides of the month occur during which moon phases?", "New and Full")
    ],
    "Phases of the Moon": [
        ("T/F: The New Moon is visible as a bright circle in the sky.", "False"),
        ("The phase between a First Quarter and a Full Moon is the: A) Waxing Crescent, B) Waxing Gibbous, C) Waning Gibbous", "B"),
        ("T/F: The Moon orbits the Earth approximately once every 29.5 days.", "True"),
        ("When the visible portion of the Moon is decreasing, it is said to be:", "Waning"),
        ("T/F: A solar eclipse can only occur during a Full Moon.", "False"),
        ("The phase immediately following a Full Moon is the: A) Third Quarter, B) Waning Gibbous, C) Waxing Gibbous", "B"),
        ("T/F: Lunar phases are caused by Earth's shadow falling on the Moon.", "False"),
        ("What is the term for when the Moon is less than half-lit?", "Crescent"),
        ("T/F: The same side of the Moon always faces the Earth.", "True"),
        ("The phase where exactly half of the Moon is illuminated is called the:", "Quarter")
    ],
    "Navigation by the Stars": [
        ("T/F: The North Star (Polaris) is the brightest star in the night sky.", "False"),
        ("Which star is crucial for navigation in the Northern Hemisphere as it aligns with Earth's axis?", "Polaris"),
        ("T/F: The position of Polaris in the sky changes significantly throughout the night.", "False"),
        ("The constellation used to 'point' to the North Star is: A) Orion, B) Ursa Major (Big Dipper), C) Cygnus", "B"),
        ("T/F: The Southern Cross constellation is used to find the South Celestial Pole.", "True"),
        ("The imaginary sphere surrounding the Earth upon which all stars appear to be located is the:", "Celestial Sphere"),
        ("T/F: The altitude (angle above the horizon) of the North Star is equal to the observer's latitude.", "True"),
        ("Navigation using the stars relies on the fact that the stars: A) Emit sound waves, B) Maintain constant positions relative to each other, C) Have changing brightness", "B"),
        ("T/F: The star Rigel is part of the constellation Orion.", "True"),
        ("The apparent path of the Sun across the sky over the course of a year is called the:", "Ecliptic")
    ]
}

def get_random_question():
    """Selects a random question from the entire bank."""
    category = random.choice(list(QUIZ_BANK.keys()))
    return random.choice(QUIZ_BANK[category])
