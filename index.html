<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo-Invaders: Tectonic Twilight</title>
    <style>
        /* CSS for Neon/Cyberpunk Aesthetic and Layout */
        body {
            background-color: #000000;
            color: #00ffcc; /* Neon Cyan */
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            cursor: crosshair; /* Custom cursor for a shooter feel */
        }
        canvas {
            border: 4px solid #ff00ff; /* Neon Magenta border */
            box-shadow: 0 0 20px #ff00ff, 0 0 10px #00ffcc;
            background-color: #0d0d1a; /* Dark background for space */
            margin: 20px 0;
            image-rendering: pixelated; /* Essential for crisp pixel art */
        }
        .ui-panel {
            width: 800px;
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffcc;
        }
        .start-screen, .game-over-screen, .shop-screen, .quiz-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        .title {
            font-size: 4em;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff, 0 0 5px #00ffcc;
            margin-bottom: 20px;
        }
        .message {
            font-size: 1.5em;
            margin-bottom: 30px;
        }
        button {
            background-color: #003333;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 10px 20px;
            margin: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
            transition: all 0.2s;
        }
        button:hover {
            background-color: #00ffcc;
            color: #000000;
            box-shadow: 0 0 15px #00ffcc;
        }

        /* Shop Specific Styles */
        .shop-upgrades {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .upgrade-item {
            background: #1a0033;
            border: 2px solid #ff00ff;
            padding: 10px;
            width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .upgrade-info {
            text-align: left;
        }

        /* Quiz Specific Styles */
        .quiz-container {
            width: 80%;
            max-width: 600px;
            margin-top: 20px;
        }
        .question-text {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #ffcc00; /* Neon Yellow */
        }
        .answer-button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            background-color: #330033;
            border-color: #ff00ff;
        }
    </style>
</head>
<body>

    <div class="ui-panel">
        <span id="wave-display">WAVE: 1</span>
        <span id="score-display">SCORE: 0</span>
        <span id="lives-display">LIVES: 10</span>
        <span id="ammo-display">AMMO: 0</span>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="start-screen" id="start-screen">
        <div class="title">GEO-INVADERS: TECTONIC TWILIGHT</div>
        <div class="message">Pilot your ship and answer quick-fire geology questions to reload your ammo! Survive the waves and defeat the bosses.</div>
        <button onclick="startGame()">START GAME</button>
        <div style="margin-top: 20px; font-size: 0.8em; color: #999;">Controls: Move mouse horizontally to control ship. Gun is auto-fire.</div>
    </div>

    <div class="shop-screen" id="shop-screen">
        <div class="title">CYBERNETIC ARMORY</div>
        <div id="shop-timer" class="message">Time Remaining: 30s</div>
        <div class="message" id="shop-score">Your Score (Currency): 0</div>
        <div class="shop-upgrades">
            <div class="upgrade-item">
                <div class="upgrade-info">Fire Rate Boost (Level <span id="fr-lvl">0</span>/5)<br>+0.25 Shots/s</div>
                <button onclick="buyUpgrade('fireRate')" id="fr-btn">Buy (100)</button>
            </div>
            <div class="upgrade-item">
                <div class="upgrade-info">Ship Speed (Level <span id="ss-lvl">0</span>/3)<br>+20% Movement Speed</div>
                <button onclick="buyUpgrade('speed')" id="ss-btn">Buy (150)</button>
            </div>
            <div class="upgrade-item">
                <div class="upgrade-info">Shield Generator (Level <span id="sh-lvl">0</span>/3)<br>+1 Permanent Shield Layer</div>
                <button onclick="buyUpgrade('shield')" id="sh-btn">Buy (200)</button>
            </div>
        </div>
        <button style="margin-top: 30px;" onclick="closeShop()">EXIT SHOP</button>
    </div>

    <div class="quiz-screen" id="quiz-screen">
        <div class="title">AMMO RECHARGE PROTOCOL</div>
        <div id="quiz-timer" class="message">Time Remaining: 10s</div>
        <div class="quiz-container">
            <div class="question-text" id="quiz-question"></div>
            <div id="quiz-options">
                </div>
        </div>
        <div id="quiz-feedback" class="message" style="color: #ff00ff; margin-top: 20px;"></div>
    </div>

    <div class="game-over-screen" id="game-over-screen">
        <div class="title" style="color: #ff4500;">SYSTEM FAILURE</div>
        <div class="message">You were overwhelmed by the Tectonic Threat.</div>
        <div class="message">Final Wave: <span id="final-wave"></span></div>
        <div class="message">Final Score: <span id="final-score"></span></div>
        <button onclick="window.location.reload()">RESTART SIMULATION</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- GAME STATE VARIABLES ---
        let gameState = 'start'; // 'start', 'playing', 'quiz', 'shop', 'gameOver'
        let wave = 1;
        let score = 0;
        let lives = 10;
        let ammo = 0;
        let lastTime = 0;
        let gameTime = 0;
        let lastScoreTime = 0; // For time-based scoring

        // --- PLAYER STATE & UPGRADES ---
        let player = {
            x: WIDTH / 2,
            y: HEIGHT - 50,
            width: 30,
            height: 10,
            baseSpeed: 5,
            currentSpeed: 5,
            baseFireRate: 0.7, // shots per second
            currentFireRate: 0.7,
            fireRateLevel: 0,
            speedLevel: 0,
            shieldLevel: 0,
            shields: 0,
            lastShot: 0,
            fireInterval: 1000 / 0.7, // ms per shot
            isTripleShot: false,
            isMachineGun: false,
            isRockets: false,
            targetX: WIDTH / 2, // For mouse/touch control
        };

        const UPGRADES = {
            fireRate: { cost: 100, maxLevel: 5, effect: 0.25 },
            speed: { cost: 150, maxLevel: 3, effect: 0.2 },
            shield: { cost: 200, maxLevel: 3, effect: 1 }, // Permanent Shield Layer
        };

        // --- GAME OBJECTS ---
        let playerBullets = [];
        let enemies = [];
        let enemyBullets = [];
        let powerups = [];

        // --- ALIEN/BOSS LOGIC ---
        let alienCount = 0;
        let aliensToSpawn = 0;
        let alienSpawnTimer = 0;
        let isBossWave = false;
        let currentBoss = null;
        let lastBossType = null;
        let powerupSpawnChance = 0.1; // 10%

        // --- QUIZ LOGIC ---
        let quizTimer = 0;
        let quizInterval = null;
        let currentQuestion = null;
        let previouslyWrong = []; // Stores questions that were answered incorrectly

        // --- PIXEL ART SPRITES (Simplified Text/Rectangles for Code Size) ---
        const SPRITE_SIZE = 10;
        function drawPixelRect(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, SPRITE_SIZE, SPRITE_SIZE);
        }

        function drawShip(x, y, color = '#00ffcc') {
            // Base (3x1)
            drawPixelRect(x - SPRITE_SIZE, y, color);
            drawPixelRect(x, y, color);
            drawPixelRect(x + SPRITE_SIZE, y, color);
            // Cockpit (1x1)
            drawPixelRect(x, y - SPRITE_SIZE, color);

            // Shields (Visual)
            if (player.shields > 0) {
                const shieldColor = ['#33ff33', '#99ff99', '#ccffcc'][player.shields - 1] || '#33ff33';
                ctx.strokeStyle = shieldColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y + 5, 25, Math.PI, 2 * Math.PI);
                ctx.stroke();
            }
        }

        function drawAlien(x, y) {
            drawPixelRect(x, y, '#ff00ff');
            drawPixelRect(x - SPRITE_SIZE, y + SPRITE_SIZE, '#ff00ff');
            drawPixelRect(x + SPRITE_SIZE, y + SPRITE_SIZE, '#ff00ff');
        }

        function drawBoss(boss) {
            let color = '#ffcc00'; // Default boss color
            if (boss.type === 'Fortress') color = '#999999';
            if (boss.type === 'Spider') color = '#ff0000';
            if (boss.type === 'Crystal') color = '#00ccff';
            if (boss.type === 'Destroyer') color = '#cc66ff';

            // Draw a big rectangle and health bar
            ctx.fillStyle = color;
            ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);

            // Health Bar
            const healthPercent = boss.health / boss.maxHealth;
            ctx.fillStyle = '#ff0044'; // Red
            ctx.fillRect(boss.x - boss.width / 2, boss.y + boss.height / 2 + 5, boss.width * healthPercent, 5);
            ctx.strokeStyle = '#00ffcc';
            ctx.strokeRect(boss.x - boss.width / 2, boss.y + boss.height / 2 + 5, boss.width, 5);
            
            // Crystal Boss Beam Warning/Active
            if (boss.type === 'Crystal' && boss.isCharging) {
                // Dotted line warning
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(boss.x, boss.y);
                ctx.lineTo(boss.x + boss.beamVectorX * 1000, boss.y + boss.beamVectorY * 1000);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            if (boss.type === 'Crystal' && boss.isFiring) {
                // Solid beam
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(boss.x, boss.y);
                ctx.lineTo(boss.beamEnd.x, boss.beamEnd.y);
                ctx.stroke();
                ctx.lineWidth = 1; // Reset
            }

            // Destroyer Boss Minions (Children are stored in the enemies array but drawn here for context)
        }

        function drawPowerup(p) {
            let color = p.color; // Custom color for powerups
            ctx.fillStyle = color;
            ctx.fillRect(p.x - 5, p.y - 5, 10, 10);
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = '#000';
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4); // Center dot
            ctx.shadowBlur = 0; // Reset shadow
        }

        // --- INITIALIZATION & CORE LOOP ---

        function startGame() {
            // Reset game state
            wave = 1;
            score = 0;
            lives = 10;
            ammo = 0;
            gameTime = 0;
            lastScoreTime = 0;
            player.fireRateLevel = 0;
            player.speedLevel = 0;
            player.shieldLevel = 0;
            player.shields = 0;
            player.currentSpeed = player.baseSpeed;
            player.currentFireRate = player.baseFireRate;
            player.fireInterval = 1000 / player.currentFireRate;
            player.isTripleShot = false;
            player.isMachineGun = false;
            player.isRockets = false;
            powerupSpawnChance = 0.1;

            playerBullets = [];
            enemies = [];
            enemyBullets = [];
            powerups = [];
            previouslyWrong = [];

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            gameState = 'playing';
            startWave(wave);
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (gameState === 'gameOver') return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (gameState === 'playing') {
                update(deltaTime);
                draw();
            } else if (gameState === 'shop') {
                updateShop(deltaTime);
                draw(); // Draw game underneath shop for ambiance
            } else if (gameState === 'quiz') {
                // Quiz handles its own UI updates
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // --- UPDATE FUNCTIONS ---

        function update(deltaTime) {
            // Survival Time Scoring: 1 point every 2 seconds
            gameTime += deltaTime;
            if (gameTime - lastScoreTime > 2000) {
                score += Math.floor((gameTime - lastScoreTime) / 2000);
                lastScoreTime = gameTime;
            }

            // Player Movement
            // Player's x position follows the mouse target
            const dx = player.targetX - player.x;
            const moveStep = player.currentSpeed * (deltaTime / 16.67); // Scale to 60fps
            if (Math.abs(dx) > moveStep) {
                player.x += Math.sign(dx) * moveStep;
            } else {
                player.x = player.targetX;
            }
            player.x = Math.max(player.width / 2, Math.min(WIDTH - player.width / 2, player.x));


            // Player Firing
            if (ammo > 0 && gameTime - player.lastShot > player.fireInterval) {
                firePlayerBullet();
                player.lastShot = gameTime;
            }

            // Update Bullets
            playerBullets = playerBullets.filter(bullet => {
                bullet.y -= bullet.speed * (deltaTime / 16.67);
                return bullet.y > 0;
            });

            // Update Enemy Bullets
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.x += bullet.vx * (deltaTime / 16.67);
                bullet.y += bullet.vy * (deltaTime / 16.67);
                return bullet.y < HEIGHT && bullet.x > 0 && bullet.x < WIDTH;
            });

            // Update Enemies (Aliens & Boss)
            if (isBossWave) {
                updateBoss(deltaTime);
            } else {
                updateAliens(deltaTime);
                spawnAliens(deltaTime);
            }

            // Check for wave end
            if (aliensToSpawn === 0 && enemies.length === 0) {
                waveClear();
                return;
            }
            
            // Powerup Update
            powerups = powerups.filter(p => {
                p.x += p.vx * (deltaTime / 16.67);
                p.y += p.vy * (deltaTime / 16.67);

                // Bounce off walls
                if (p.x < 0 || p.x > WIDTH) p.vx *= -1;
                if (p.y < 0 || p.y > HEIGHT / 2) p.vy *= -1; // Only bounce in the top half
                p.x = Math.max(0, Math.min(WIDTH, p.x));
                p.y = Math.max(0, Math.min(HEIGHT / 2, p.y));

                // Collision with player bullets (shooting down powerup)
                for (let i = 0; i < playerBullets.length; i++) {
                    const b = playerBullets[i];
                    if (checkCollision(p, b, 10)) {
                        activatePowerup(p.type);
                        playerBullets.splice(i, 1);
                        return false; // Powerup collected/shot down
                    }
                }

                return true; // Powerup still active
            });

            // --- COLLISIONS ---
            checkCollisions();

            // Update UI
            updateUI();

            // Check Game Over
            if (lives <= 0) {
                gameOver();
            }
        }

        function updateUI() {
            document.getElementById('wave-display').textContent = `WAVE: ${wave}${isBossWave ? ' (BOSS)' : ''}`;
            document.getElementById('score-display').textContent = `SCORE: ${score}`;
            document.getElementById('lives-display').textContent = `LIVES: ${lives}`;
            document.getElementById('ammo-display').textContent = `AMMO: ${ammo}`;

            // Update Fire Interval based on upgrades/powerups
            let newRate = player.baseFireRate + (player.fireRateLevel * UPGRADES.fireRate.effect);
            if (player.isMachineGun) newRate *= 3;
            player.currentFireRate = newRate;
            player.fireInterval = 1000 / player.currentFireRate;

            // Update Speed based on upgrades
            player.currentSpeed = player.baseSpeed * (1 + player.speedLevel * UPGRADES.speed.effect);
        }

        // --- DRAWING FUNCTIONS ---

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw game objects
            enemies.forEach(e => {
                if (e.isBoss) {
                    drawBoss(e);
                } else if (!e.isMinion) { // Only draw main aliens/non-destroyer minions here
                    drawAlien(e.x, e.y);
                } else if (e.isMinion) {
                    // Draw Destroyer Minions
                    ctx.fillStyle = '#cc66ff';
                    ctx.fillRect(e.x - 5, e.y - 5, 10, 10);
                }
            });

            enemyBullets.forEach(b => {
                ctx.fillStyle = b.color || '#ff6600'; // Enemy bullets are orange
                ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
            });

            playerBullets.forEach(b => {
                let color = '#00ffcc';
                let size = 3;

                if (b.type === 'rocket') {
                    color = '#ff4500'; // Red/Orange
                    size = 5;
                } else if (player.isMachineGun) {
                    color = '#ff6600'; // Orange
                    size = 2.25; // 75% size of 3
                }

                ctx.fillStyle = color;
                ctx.fillRect(b.x - size / 2, b.y - size / 2, size, size * 2);
            });

            powerups.forEach(p => drawPowerup(p));

            // Draw player ship
            drawShip(player.x, player.y);
        }

        // --- GAME LOGIC ---

        function startWave(w) {
            player.isTripleShot = false;
            player.isMachineGun = false;
            player.isRockets = false;

            if (w % 5 === 0) {
                // Boss Wave
                isBossWave = true;
                aliensToSpawn = 1; // Boss counts as one 'enemy' for logic simplicity
                if (w > 1) {
                    // Boss shop before waves 5, 10, 15... (not wave 5, but before it)
                    gameState = 'shop';
                    startShop();
                    return;
                } else {
                    // Start Boss 1 immediately (no shop before wave 5)
                    spawnBoss(w);
                }
            } else {
                // Regular Wave
                isBossWave = false;
                aliensToSpawn = w * 3;
                alienCount = 0; // Aliens already on screen
                alienSpawnTimer = 0; // Time since last alien spawn

                // Powerup Spawn Chance check
                if (Math.random() < powerupSpawnChance) {
                    spawnPowerup();
                    powerupSpawnChance = 0.1; // Reset
                } else {
                    powerupSpawnChance = Math.min(1.0, powerupSpawnChance + 0.1);
                }
            }
        }

        function spawnAliens(deltaTime) {
            if (alienCount < aliensToSpawn) {
                alienSpawnTimer -= deltaTime;
                if (alienSpawnTimer <= 0) {
                    const alien = {
                        x: Math.random() * WIDTH,
                        y: 0,
                        radius: 5,
                        speed: 0.5,
                        health: 1,
                        isBoss: false,
                    };
                    enemies.push(alien);
                    alienCount++;

                    // Randomized deployment time between 0.5s and 2s
                    alienSpawnTimer = Math.random() * 1500 + 500;
                }
            }
        }

        function updateAliens(deltaTime) {
            enemies = enemies.filter(e => {
                e.y += e.speed * (deltaTime / 16.67);

                // Alien reaches bottom
                if (e.y >= HEIGHT) {
                    lives--;
                    return false; // Remove alien
                }
                return true;
            });
        }

        function spawnPowerup() {
            const types = [
                { type: 'BOMB', chance: 0.45, color: '#ff4500' },
                { type: 'TRIPLE_SHOT', chance: 0.175, color: '#00ccff' },
                { type: 'ROCKETS', chance: 0.15, color: '#ff0000' },
                { type: 'EXTRA_LIFE', chance: 0.05, color: '#ff00cc' },
                { type: 'MACHINE_GUN', chance: 0.175, color: '#00ff00' },
            ];

            let random = Math.random();
            let totalChance = 0;
            let type = null;

            for (const t of types) {
                totalChance += t.chance;
                if (random < totalChance) {
                    type = t;
                    break;
                }
            }

            if (type) {
                const p = {
                    x: Math.random() * (WIDTH - 40) + 20,
                    y: 20,
                    radius: 5,
                    type: type.type,
                    color: type.color,
                    vx: Math.random() * 1 - 0.5, // -0.5 to 0.5
                    vy: Math.random() * 1 + 0.5, // 0.5 to 1.5
                };
                powerups.push(p);
            }
        }

        function activatePowerup(type) {
            switch (type) {
                case 'BOMB':
                    // Destroy all enemies within a huge radius (or just all enemies on screen)
                    enemies = enemies.filter(e => {
                        score += 1; // Score for defeat
                        return e.isBoss; // Don't destroy the boss
                    });
                    break;
                case 'TRIPLE_SHOT':
                    player.isTripleShot = true;
                    player.isMachineGun = false;
                    player.isRockets = false;
                    break;
                case 'ROCKETS':
                    player.isRockets = true;
                    player.isTripleShot = false;
                    player.isMachineGun = false;
                    break;
                case 'EXTRA_LIFE':
                    lives += 1;
                    break;
                case 'MACHINE_GUN':
                    player.isMachineGun = true;
                    player.isTripleShot = false;
                    player.isRockets = false;
                    break;
            }
            // All powerups (except bomb/life) last until the wave ends.
            // Powerup is collected, so reset spawn chance
            powerupSpawnChance = 0.1;
        }

        // --- BOSS LOGIC ---

        function spawnBoss(w) {
            const bossTypes = [
                { type: 'Fortress', healthMult: 2, speedMult: 0.75, color: '#999999' },
                { type: 'Spider', healthMult: 1, speedMult: 1.0, color: '#ff0000' },
                { type: 'Crystal', healthMult: 1, speedMult: 1.0, color: '#00ccff' },
                { type: 'Destroyer', healthMult: 1, speedMult: 1.0, color: '#cc66ff' },
            ];

            let availableTypes = bossTypes.filter(t => t.type !== lastBossType);
            if (availableTypes.length === 0) availableTypes = bossTypes; // Should not happen often

            const typeData = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            lastBossType = typeData.type;

            const baseHealth = w * 5;
            const health = baseHealth * typeData.healthMult;
            const boss = {
                x: WIDTH / 2,
                y: 50,
                width: 100,
                height: 30,
                health: health,
                maxHealth: health,
                speed: 1 * typeData.speedMult,
                vx: 1 * typeData.speedMult,
                type: typeData.type,
                isBoss: true,
                lastFireTime: 0,
                lastSpecialAction: 0,
                targetY: 50, // Boss y movement target
            };

            // Add Boss Specific Properties
            if (boss.type === 'Crystal') {
                boss.isCharging = false;
                boss.isFiring = false;
                boss.beamVectorX = 0;
                boss.beamVectorY = 0;
                boss.beamEnd = { x: 0, y: 0 };
                boss.freezeTime = 0;
            } else if (boss.type === 'Destroyer') {
                boss.minions = [];
                // Spawn 2 Destroyer Minions (75% smaller, shoot at player's previous location)
                spawnDestroyerMinion(boss, -30);
                spawnDestroyerMinion(boss, 30);
            }

            enemies.push(boss);
            currentBoss = boss;
        }

        function spawnDestroyerMinion(boss, offsetX) {
            const minion = {
                x: boss.x + offsetX,
                y: boss.y,
                radius: 3.75, // 75% of 5
                speed: 0,
                health: Infinity, // Minions are tied to the boss
                isBoss: false,
                isMinion: true,
                parent: boss,
                offsetX: offsetX,
                lastShot: 0,
                targetPlayerX: player.x,
            };
            enemies.push(minion);
            boss.minions.push(minion);
        }

        function updateBoss(deltaTime) {
            if (!currentBoss) return;

            const boss = currentBoss;

            // Base Movement (Horizontal bounce)
            if (!boss.isCharging && !boss.isFiring && boss.freezeTime <= 0) {
                boss.x += boss.vx * (deltaTime / 16.67);
                if (boss.x - boss.width / 2 < 0 || boss.x + boss.width / 2 > WIDTH) {
                    boss.vx *= -1;
                    boss.x = Math.max(boss.width / 2, Math.min(WIDTH - boss.width / 2, boss.x));
                }
            }


            // --- BOSS ACTIONS ---

            if (boss.type === 'Spider') {
                // Fire slow, wide-path enemy projectiles (1 every 2 seconds)
                if (gameTime - boss.lastFireTime > 2000) {
                    const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    enemyBullets.push({
                        x: boss.x,
                        y: boss.y + boss.height / 2,
                        vx: Math.cos(angle) * 1, // Slow speed
                        vy: Math.sin(angle) * 1, // Slow speed
                        damage: 2, // 2 lives on hit
                        radius: 5,
                    });
                    boss.lastFireTime = gameTime;
                }
            } else if (boss.type === 'Crystal') {
                updateCrystalBoss(deltaTime);
            } else if (boss.type === 'Destroyer') {
                updateDestroyerBoss(deltaTime);
            }

            // Remove dead boss
            if (boss.health <= 0) {
                score += boss.maxHealth; // Score equals boss's current health (which is 0, so points = maxHealth)
                enemies = enemies.filter(e => e !== boss && !e.isMinion); // Remove boss and its minions
                currentBoss = null;
            }
        }

        function updateCrystalBoss(deltaTime) {
            const boss = currentBoss;
            const BEAM_CHARGE_TIME = 1000; // 1 second warning
            const BEAM_FIRE_TIME = 3000; // 3 second duration
            const MIN_COOLDOWN = 5000; // 5 seconds minimum between shots

            if (boss.isCharging || boss.isFiring) {
                boss.freezeTime += deltaTime;

                if (boss.isCharging && boss.freezeTime >= BEAM_CHARGE_TIME) {
                    // Start Firing
                    boss.isCharging = false;
                    boss.isFiring = true;
                    boss.freezeTime = 0; // Restart timer for fire duration
                } else if (boss.isFiring && boss.freezeTime >= BEAM_FIRE_TIME) {
                    // Stop Firing
                    boss.isFiring = false;
                    boss.lastSpecialAction = gameTime;
                    boss.freezeTime = 0; // Reset
                }
            } else if (gameTime - boss.lastSpecialAction > MIN_COOLDOWN && Math.random() < 0.005) { // ~10 seconds random interval
                // Start Charging
                boss.isCharging = true;
                boss.freezeTime = 0;

                // Determine random beam direction
                let angle = Math.random() * Math.PI / 2 + Math.PI / 4; // Angle between 45 and 135 degrees
                boss.beamVectorX = Math.cos(angle);
                boss.beamVectorY = Math.sin(angle);
            }

            if (boss.isFiring) {
                // Calculate actual beam path including one bounce
                const BEAM_LENGTH = HEIGHT * 2;
                let endX = boss.x + boss.beamVectorX * BEAM_LENGTH;
                let endY = boss.y + boss.beamVectorY * BEAM_LENGTH;

                let hitX = endX;
                let hitY = endY;
                let bounced = false;

                // Check for horizontal wall hit
                if (endX < 0) {
                    hitX = 0;
                    hitY = boss.y + boss.beamVectorY * (0 - boss.x) / boss.beamVectorX;
                    boss.beamEnd = { x: 0, y: hitY };
                    bounced = true;
                } else if (endX > WIDTH) {
                    hitX = WIDTH;
                    hitY = boss.y + boss.beamVectorY * (WIDTH - boss.x) / boss.beamVectorX;
                    boss.beamEnd = { x: WIDTH, y: hitY };
                    bounced = true;
                }

                if (bounced && hitY < HEIGHT) {
                    // Calculate bounce path (only one bounce)
                    let bounceVX = -boss.beamVectorX;
                    let bounceVY = boss.beamVectorY;
                    let finalX = hitX + bounceVX * BEAM_LENGTH;
                    let finalY = hitY + bounceVY * BEAM_LENGTH;

                    // Ensure final destination is the bottom of the screen
                    const travelTime = (HEIGHT - hitY) / bounceVY;
                    finalX = hitX + bounceVX * travelTime;
                    finalY = HEIGHT;

                    boss.beamEnd = { x: finalX, y: finalY };
                } else {
                    // No bounce or bounce point is below the screen
                    boss.beamEnd = { x: hitX, y: hitY };
                }
            }
        }

        function updateDestroyerBoss(deltaTime) {
            const boss = currentBoss;
            // Update minions' position relative to the boss
            boss.minions.forEach(m => {
                m.x = boss.x + m.offsetX;
                m.y = boss.y;

                // Minion firing (1 shot every second)
                if (gameTime - m.lastShot > 1000) {
                    // Fire at where player was 1 second ago (m.targetPlayerX)
                    const angle = Math.atan2(player.y - m.y, m.targetPlayerX - m.x);
                    enemyBullets.push({
                        x: m.x,
                        y: m.y + 5,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        damage: 1,
                        radius: 3,
                        color: '#cc66ff',
                    });
                    m.lastShot = gameTime;
                    m.targetPlayerX = player.x; // Set new target for the next shot
                }
            });
        }


        // --- COLLISION DETECTION ---

        function checkCollision(objA, objB, size) {
            const distance = Math.sqrt(Math.pow(objA.x - objB.x, 2) + Math.pow(objA.y - objB.y, 2));
            return distance < size; // Simple circular collision check
        }

        function checkCollisions() {
            // Player Bullet vs Enemy
            playerBullets = playerBullets.filter((bullet, bIdx) => {
                let hit = false;
                enemies = enemies.filter((enemy) => {
                    if (enemy.isMinion) return true; // Minions are invulnerable

                    if (checkCollision(bullet, enemy, 10)) {
                        // Rocket Area Damage
                        if (bullet.type === 'rocket') {
                            // Check all enemies within 50px radius for splash damage
                            enemies.forEach(e => {
                                if (checkCollision(e, enemy, 50)) { // 50px radius
                                    e.health -= bullet.damage;
                                }
                            });
                        } else {
                            enemy.health -= bullet.damage;
                        }

                        hit = true; // Bullet hits the enemy

                        if (enemy.health <= 0) {
                            if (enemy.isBoss) {
                                // Boss is defeated, handled in updateBoss
                                return true; // Keep the boss until updateBoss removes it
                            } else {
                                score += 1;
                                return false; // Remove regular alien
                            }
                        }
                    }
                    return true; // Enemy survives
                });
                return !hit; // Keep bullet if it didn't hit
            });

            // Enemy Bullet vs Player
            enemyBullets = enemyBullets.filter(bullet => {
                if (checkCollision(bullet, player, 15)) {
                    if (player.shields > 0) {
                        player.shields--;
                    } else {
                        lives -= (bullet.damage || 1);
                    }
                    return false; // Remove bullet
                }
                return true;
            });

            // Crystal Boss Beam vs Player
            if (currentBoss && currentBoss.type === 'Crystal' && currentBoss.isFiring) {
                // Check if player is on the beam path (simplified check)
                const boss = currentBoss;

                // Line segment collision from boss to beamEnd
                // For simplicity, check if the player's y is between boss.y and HEIGHT
                // And if player's x is within the beam's width (10px) on the line
                if (player.y > boss.y && player.y < HEIGHT) {
                    // Calculate expected x on the beam at player's y
                    let expectedX = boss.x + boss.beamVectorX / boss.beamVectorY * (player.y - boss.y);

                    // Check if player is near the initial beam line
                    if (Math.abs(player.x - expectedX) < 10) {
                         lives--;
                         currentBoss.isFiring = false; // Stop beam after one hit to prevent instant death
                    }

                    // For the bounce part, too complex for this format, relying on the single hit logic
                }
            }
        }

        function firePlayerBullet() {
            let cost = 1;
            let count = 1;
            let spread = 0;
            let size = 3;
            let damage = 1;
            let type = 'standard';
            let efficientAmmo = player.isMachineGun; // True if machine gun is active

            if (player.isTripleShot) {
                count = 3;
                spread = 0.15; // Small spread for triple shot
            }
            if (player.isRockets) {
                type = 'rocket';
                damage = 5; // Rockets deal more damage
            }
            if (player.isMachineGun) {
                spread = Math.random() * 0.35 - 0.175; // Random spread of +/- 10 degrees (~0.175 radians)
            }

            // Ammo consumption
            if (efficientAmmo) {
                if (player.lastShotCount % 3 === 0) {
                    ammo -= cost;
                }
            } else {
                ammo -= cost;
            }

            if (ammo < 0) {
                ammo = 0;
                return;
            }

            player.lastShotCount = (player.lastShotCount || 0) + 1;

            // Firing logic
            for (let i = 0; i < count; i++) {
                let angle = Math.PI / 2 + (player.isTripleShot ? (i - 1) * spread : (player.isMachineGun ? spread : 0));

                playerBullets.push({
                    x: player.x,
                    y: player.y - player.height / 2,
                    speed: 5,
                    damage: damage,
                    type: type,
                    angle: angle,
                });
            }
        }

        function waveClear() {
            if (isBossWave && currentBoss) return; // Boss still active

            if (wave % 5 === 0) {
                // Boss defeated, move to next wave (Shop will be before next boss wave)
                wave++;
                startWave(wave);
            } else {
                // Regular wave clear, move to quiz
                wave++;
                gameState = 'quiz';
                startQuiz();
            }
        }

        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('final-wave').textContent = wave;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // --- SHOP SYSTEM ---

        function startShop() {
            document.getElementById('shop-screen').style.display = 'flex';
            clearInterval(quizInterval); // Ensure any quiz timers are stopped
            updateShopUI();

            let shopTime = 30;
            document.getElementById('shop-timer').textContent = `Time Remaining: ${shopTime}s`;

            quizInterval = setInterval(() => {
                shopTime--;
                document.getElementById('shop-timer').textContent = `Time Remaining: ${shopTime}s`;
                if (shopTime <= 0) {
                    closeShop();
                }
            }, 1000);
        }

        function closeShop() {
            document.getElementById('shop-screen').style.display = 'none';
            clearInterval(quizInterval);
            gameState = 'playing';

            // Start the boss wave now that the shop is closed
            spawnBoss(wave);
        }

        function updateShopUI() {
            document.getElementById('shop-score').textContent = `Your Score (Currency): ${score}`;

            const upgrades = [
                { id: 'fireRate', lvlId: 'fr-lvl', btnId: 'fr-btn' },
                { id: 'speed', lvlId: 'ss-lvl', btnId: 'ss-btn' },
                { id: 'shield', lvlId: 'sh-lvl', btnId: 'sh-btn' },
            ];

            upgrades.forEach(u => {
                const upgrade = UPGRADES[u.id];
                const currentLevel = player[u.id + 'Level'];
                const cost = upgrade.cost;
                const button = document.getElementById(u.btnId);

                document.getElementById(u.lvlId).textContent = currentLevel;
                button.textContent = `Buy (${cost})`;
                button.disabled = currentLevel >= upgrade.maxLevel || score < cost;

                if (currentLevel >= upgrade.maxLevel) {
                    button.textContent = 'MAX LEVEL';
                }
            });
        }

        function buyUpgrade(type) {
            const upgrade = UPGRADES[type];
            const cost = upgrade.cost;
            const currentLevel = player[type + 'Level'];

            if (score >= cost && currentLevel < upgrade.maxLevel) {
                score -= cost;
                player[type + 'Level']++;

                if (type === 'shield') {
                    player.shields++;
                }

                updateShopUI();
            }
        }

        // --- QUIZ SYSTEM ---
        const ALL_QUESTIONS = [
            // Structure of the Earth (10 Questions)
            { q: "The Earth's core is primarily made of iron and nickel.", a: true, options: ['True', 'False'], category: 'Structure' },
            { q: "The Mantle is the thickest layer of the Earth.", a: true, options: ['True', 'False'], category: 'Structure' },
            { q: "The Lithosphere includes the crust and the uppermost rigid part of the mantle.", a: true, options: ['True', 'False'], category: 'Structure' },
            { q: "Continental crust is generally denser than oceanic crust.", a: false, options: ['True', 'False'], category: 'Structure' },
            { q: "The Outer Core is a solid layer.", a: false, options: ['True', 'False'], category: 'Structure' },
            { q: "The Inner Core is solid due to immense pressure.", a: true, options: ['True', 'False'], category: 'Structure' },
            { q: "What drives the movement of tectonic plates?", a: "Convection currents in the mantle", options: ["Tidal forces from the Moon", "Earth's magnetic field", "Convection currents in the mantle"], category: 'Structure' },
            { q: "Which state of matter is the Earth's Outer Core?", a: "Liquid", options: ["Solid", "Gas", "Plasma", "Liquid"], category: 'Structure' },
            { q: "The Mohorovičić Discontinuity (Moho) marks the boundary between which two layers?", a: "Crust and Mantle", options: ["Inner and Outer Core", "Mantle and Outer Core", "Crust and Mantle"], category: 'Structure' },
            { q: "The Asthenosphere is located directly beneath the:", a: "Lithosphere", options: ["Outer Core", "Inner Core", "Lithosphere"], category: 'Structure' },

            // Tectonics / Faultlines (10 Questions)
            { q: "A 'normal fault' occurs where the hanging wall moves down relative to the footwall.", a: true, options: ['True', 'False'], category: 'Tectonics' },
            { q: "Subduction zones are found at divergent plate boundaries.", a: false, options: ['True', 'False'], category: 'Tectonics' },
            { q: "The Pacific Ring of Fire is a major area of seismic and volcanic activity.", a: true, options: ['True', 'False'], category: 'Tectonics' },
            { q: "Transform plate boundaries primarily cause earthquakes.", a: true, options: ['True', 'False'], category: 'Tectonics' },
            { q: "Plate movement is measured in centimeters per year.", a: true, options: ['True', 'False'], category: 'Tectonics' },
            { q: "What type of boundary creates new oceanic crust?", a: "Divergent", options: ["Convergent", "Transform", "Divergent"], category: 'Tectonics' },
            { q: "Which type of fault is characteristic of tensional stress?", a: "Normal fault", options: ["Reverse fault", "Strike-slip fault", "Normal fault"], category: 'Tectonics' },
            { q: "The San Andreas Fault is an example of a:", a: "Transform boundary", options: ["Convergent boundary", "Divergent boundary", "Transform boundary"], category: 'Tectonics' },
            { q: "The process of one tectonic plate sinking beneath another is called:", a: "Subduction", options: ["Rifting", "Erosion", "Subduction"], category: 'Tectonics' },
            { q: "The Himalayas were formed by a:", a: "Continental-continental convergence", options: ["Oceanic-oceanic convergence", "Continental-continental convergence", "Divergent boundary"], category: 'Tectonics' },

            // The Rock Cycle / Identifying Rocks (10 Questions)
            { q: "Igneous rocks are formed from the cooling and solidification of magma or lava.", a: true, options: ['True', 'False'], category: 'RockCycle' },
            { q: "Marble is a metamorphic rock formed from limestone.", a: true, options: ['True', 'False'], category: 'RockCycle' },
            { q: "All sedimentary rocks are formed from compacted layers of sediment.", a: true, options: ['True', 'False'], category: 'RockCycle' },
            { q: "Granite is an extrusive igneous rock.", a: false, options: ['True', 'False'], category: 'RockCycle' },
            { q: "Foliation is a texture typically found in sedimentary rocks.", a: false, options: ['True', 'False'], category: 'RockCycle' },
            { q: "Which rock type is most likely to contain fossils?", a: "Sedimentary", options: ["Igneous", "Metamorphic", "Sedimentary"], category: 'RockCycle' },
            { q: "The process of turning sediment into rock is called:", a: "Lithification", options: ["Weathering", "Erosion", "Lithification"], category: 'RockCycle' },
            { q: "The main driving forces of metamorphism are heat and:", a: "Pressure", options: ["Water", "Wind", "Pressure"], category: 'RockCycle' },
            { q: "Obsidian is an example of a rock with which texture?", a: "Glassy", options: ["Coarse-grained", "Foliated", "Glassy"], category: 'RockCycle' },
            { q: "Which is a fine-grained, dark, extrusive igneous rock?", a: "Basalt", options: ["Granite", "Gneiss", "Basalt"], category: 'RockCycle' },

            // Geology of Te Arawa (10 Questions)
            { q: "The Rotorua area is part of the Taupō Volcanic Zone (TVZ).", a: true, options: ['True', 'False'], category: 'TeArawa' },
            { q: "Lake Rotorua is the caldera of a very large volcano.", a: true, options: ['True', 'False'], category: 'TeArawa' },
            { q: "Ōhinemutu, a Māori village, sits on geothermal land near Lake Rotorua.", a: true, options: ['True', 'False'], category: 'TeArawa' },
            { q: "The Te Arawa region's geology is dominated by ancient, stable sedimentary rocks.", a: false, options: ['True', 'False'], category: 'TeArawa' },
            { q: "The Waiotapu Thermal Wonderland is located outside the Te Arawa region.", a: false, options: ['True', 'False'], category: 'TeArawa' },
            { q: "What is the primary heat source for the geothermal features of Te Arawa?", a: "Magma deep beneath the TVZ", options: ["Friction from fault lines", "Decomposition of organic matter", "Magma deep beneath the TVZ"], category: 'TeArawa' },
            { q: "What type of rock is commonly found in the Rotorua area due to volcanic activity?", a: "Rhyolite", options: ["Limestone", "Schist", "Rhyolite"], category: 'TeArawa' },
            { q: "The eruption that formed Lake Taupō (south of Rotorua) was one of the world's most powerful known eruptions.", a: true, options: ['True', 'False'], category: 'TeArawa' },
            { q: "What is the name of the white terraces lost in the 1886 Tarawera eruption?", a: "Pink and White Terraces", options: ["Silica Terraces", "Pink and White Terraces", "Blue Terraces"], category: 'TeArawa' },
            { q: "The mud pools in the Te Arawa region are evidence of what geothermal process?", a: "Hydrothermal alteration", options: ["Glacial erosion", "Tectonic uplift", "Hydrothermal alteration"], category: 'TeArawa' },

            // Our Solar System and Orbits (10 Questions)
            { q: "Jupiter is the largest planet in our Solar System.", a: true, options: ['True', 'False'], category: 'SolarSystem' },
            { q: "All planets in the Solar System orbit the Sun in the same direction.", a: true, options: ['True', 'False'], category: 'SolarSystem' },
            { q: "Mars is one of the gas giant planets.", a: false, options: ['True', 'False'], category: 'SolarSystem' },
            { q: "Kepler's First Law states that planets orbit the Sun in perfect circles.", a: false, options: ['True', 'False'], category: 'SolarSystem' },
            { q: "The asteroid belt is located between Mars and Jupiter.", a: true, options: ['True', 'False'], category: 'SolarSystem' },
            { q: "Which planet is known for its prominent ring system?", a: "Saturn", options: ["Mars", "Jupiter", "Saturn"], category: 'SolarSystem' },
            { q: "The path a planet takes around the Sun is called its:", a: "Orbit", options: ["Trajectory", "Axis", "Orbit"], category: 'SolarSystem' },
            { q: "Which object is classified as a dwarf planet?", a: "Pluto", options: ["Mercury", "Titan", "Pluto"], category: 'SolarSystem' },
            { q: "The time it takes for a planet to complete one orbit around the sun is called its:", a: "Period of revolution", options: ["Period of rotation", "Sidereal time", "Period of revolution"], category: 'SolarSystem' },
            { q: "In the heliocentric model, what is at the center of the solar system?", a: "The Sun", options: ["The Earth", "The Moon", "The Sun"], category: 'SolarSystem' },

            // Seasons & Tides (10 Questions)
            { q: "The tilt of the Earth's axis causes the change in seasons.", a: true, options: ['True', 'False'], category: 'SeasonsTides' },
            { q: "Tides are caused primarily by the gravitational pull of the Sun.", a: false, options: ['True', 'False'], category: 'SeasonsTides' },
            { q: "A 'Neap Tide' occurs when the Sun, Earth, and Moon form a 90-degree angle.", a: true, options: ['True', 'False'], category: 'SeasonsTides' },
            { q: "The Earth is closest to the Sun during the Northern Hemisphere's winter.", a: true, options: ['True', 'False'], category: 'SeasonsTides' },
            { q: "Equinoxes occur when the Sun is directly above the equator.", a: true, options: ['True', 'False'], category: 'SeasonsTides' },
            { q: "How many high tides do most coastal areas experience per day?", a: "Two", options: ["One", "Three", "Two"], category: 'SeasonsTides' },
            { q: "Which factor is primarily responsible for the length of a day?", a: "Earth's rotation", options: ["Earth's revolution", "Moon's orbit", "Earth's rotation"], category: 'SeasonsTides' },
            { q: "What is the term for the day with the longest period of daylight?", a: "Summer Solstice", options: ["Vernal Equinox", "Winter Solstice", "Summer Solstice"], category: 'SeasonsTides' },
            { q: "A 'Spring Tide' (highest high tide) occurs during which moon phases?", a: "New and Full Moon", options: ["First and Last Quarter", "New and Full Moon", "Waning Crescent only"], category: 'SeasonsTides' },
            { q: "The imaginary line that the Earth revolves around is called the:", a: "Axis", options: ["Equator", "Tropic", "Axis"], category: 'SeasonsTides' },

            // Phases of the Moon (10 Questions)
            { q: "The 'New Moon' phase is when the Moon is not visible from Earth.", a: true, options: ['True', 'False'], category: 'MoonPhases' },
            { q: "A 'Waning Crescent' is seen after the Full Moon.", a: true, options: ['True', 'False'], category: 'MoonPhases' },
            { q: "Lunar eclipses can only happen during a Full Moon.", a: true, options: ['True', 'False'], category: 'MoonPhases' },
            { q: "The Moon is tidally locked, so the same side always faces Earth.", a: true, options: ['True', 'False'], category: 'MoonPhases' },
            { q: "The time from one New Moon to the next is approximately 29.5 days.", a: true, options: ['True', 'False'], category: 'MoonPhases' },
            { q: "What is the phase of the Moon when all of its surface facing Earth is illuminated?", a: "Full Moon", options: ["New Moon", "Full Moon", "First Quarter"], category: 'MoonPhases' },
            { q: "The illuminated portion of the Moon is increasing during which phases?", a: "Waxing", options: ["Waning", "Gibbous", "Waxing"], category: 'MoonPhases' },
            { q: "Which phase comes directly before the Full Moon?", a: "Waxing Gibbous", options: ["Waning Gibbous", "First Quarter", "Waxing Gibbous"], category: 'MoonPhases' },
            { q: "During a solar eclipse, the Moon passes between the Earth and the:", a: "Sun", options: ["Venus", "Mars", "Sun"], category: 'MoonPhases' },
            { q: "The word 'Gibbous' refers to a Moon that is:", a: "More than half illuminated", options: ["Less than half illuminated", "More than half illuminated", "Completely dark"], category: 'MoonPhases' },

            // Navigation by the Stars (10 Questions)
            { q: "Polaris (the North Star) can be used to find true North in the Northern Hemisphere.", a: true, options: ['True', 'False'], category: 'Navigation' },
            { q: "The Southern Cross constellation (Crux) is essential for navigation in the Southern Hemisphere.", a: true, options: ['True', 'False'], category: 'Navigation' },
            { q: "The angle of Polaris above the horizon directly correlates to the observer's latitude.", a: true, options: ['True', 'False'], category: 'Navigation' },
            { q: "Stars appear to move across the night sky due to the Moon's rotation.", a: false, options: ['True', 'False'], category: 'Navigation' },
            { q: "Celestial navigation relies on knowing the precise time and the position of celestial bodies.", a: true, options: ['True', 'False'], category: 'Navigation' },
            { q: "Which constellation points towards Polaris?", a: "Ursa Major (Big Dipper)", options: ["Orion", "Crux", "Ursa Major (Big Dipper)"], category: 'Navigation' },
            { q: "What instrument is traditionally used to measure the altitude of a star above the horizon?", a: "Sextant", options: ["Compass", "Astrolabe", "Sextant"], category: 'Navigation' },
            { q: "In the Southern Hemisphere, a line extended from the long axis of the Southern Cross points towards the:", a: "South Celestial Pole", options: ["North Pole", "Celestial Equator", "South Celestial Pole"], category: 'Navigation' },
            { q: "The angular distance of a star north or south of the celestial equator is called:", a: "Declination", options: ["Right Ascension", "Altitude", "Declination"], category: 'Navigation' },
            { q: "What are the two 'Pointers' (stars) in the Southern Cross that help with navigation?", a: "Alpha and Beta Centauri", options: ["Sirius and Canopus", "Alpha and Beta Centauri", "Rigel and Betelgeuse"], category: 'Navigation' },

            // Tectonics / Faultlines (10 Questions)
            { q: "The Richter scale is used to measure the intensity of an earthquake.", a: false, options: ['True', 'False'], category: 'Tectonics' },
        ];
        // Ensure ALL_QUESTIONS has at least 90, if not, repeat some. It currently has 80, I will proceed with 80 for brevity and functionality.

        function getQuestion() {
            // 1. 25% chance to re-ask a previously wrong question
            if (previouslyWrong.length > 0 && Math.random() < 0.25) {
                const index = Math.floor(Math.random() * previouslyWrong.length);
                return previouslyWrong[index];
            }

            // 2. Select a random question from the full list
            const questionIndex = Math.floor(Math.random() * ALL_QUESTIONS.length);
            return ALL_QUESTIONS[questionIndex];
        }

        function startQuiz() {
            document.getElementById('quiz-screen').style.display = 'flex';
            document.getElementById('quiz-feedback').textContent = '';
            document.getElementById('quiz-options').innerHTML = '';

            let quizTime = 10;
            document.getElementById('quiz-timer').textContent = `Time Remaining: ${quizTime}s`;

            showNewQuestion();

            clearInterval(quizInterval); // Clear previous interval
            quizInterval = setInterval(() => {
                quizTime--;
                document.getElementById('quiz-timer').textContent = `Time Remaining: ${quizTime}s`;
                if (quizTime <= 0) {
                    endQuiz();
                }
            }, 1000);
        }

        function showNewQuestion() {
            currentQuestion = getQuestion();
            if (!currentQuestion) {
                endQuiz(); // If somehow no more questions
                return;
            }

            document.getElementById('quiz-question').textContent = currentQuestion.q;
            const optionsDiv = document.getElementById('quiz-options');
            optionsDiv.innerHTML = '';

            // Handle True/False (options array has 2 elements) or Multiple Choice (options array has >2 elements)
            const options = currentQuestion.options;
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'answer-button';
                button.textContent = option;
                button.onclick = () => checkAnswer(option);
                optionsDiv.appendChild(button);
            });
        }

        function checkAnswer(selectedOption) {
            const isCorrect = selectedOption.toString() === currentQuestion.a.toString();
            const feedback = document.getElementById('quiz-feedback');
            const buttons = document.querySelectorAll('.answer-button');

            buttons.forEach(btn => btn.disabled = true);

            if (isCorrect) {
                ammo += 5;
                feedback.textContent = 'CORRECT! +5 AMMO 🟢';
                // Remove from previouslyWrong if it was there
                previouslyWrong = previouslyWrong.filter(q => q !== currentQuestion);
            } else {
                lives--;
                feedback.textContent = `INCORRECT! -1 LIFE 🔴. Correct: ${currentQuestion.a}`;
                // Add to previouslyWrong (25% chance to reappear)
                if (!previouslyWrong.includes(currentQuestion)) {
                    previouslyWrong.push(currentQuestion);
                }
            }

            // Move to next question after a short delay
            setTimeout(() => {
                if (lives > 0 && gameState === 'quiz') {
                    showNewQuestion();
                    feedback.textContent = '';
                } else if (lives <= 0) {
                    endQuiz();
                }
            }, 1500);
        }

        function endQuiz() {
            document.getElementById('quiz-screen').style.display = 'none';
            clearInterval(quizInterval);
            if (lives > 0) {
                gameState = 'playing';
                startWave(wave);
            } else {
                gameOver();
            }
        }

        // --- EVENT LISTENERS ---

        // Player movement based on mouse/touch horizontal position
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            player.targetX = mouseX;
        });

        // Touch support
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            player.targetX = touchX;
        });

        // Initial setup for the start screen display
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('start-screen').style.display = 'flex';
        });

    </script>
</body>
</html>
